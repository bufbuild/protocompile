// Copyright 2020-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package incremental

import (
	"context"
	"fmt"
	"runtime"
	"slices"
	"sync"
	"sync/atomic"

	"golang.org/x/sync/semaphore"

	"github.com/bufbuild/protocompile/experimental/report"
)

// Executor is a caching executor for incremental queries.
//
// See [New], [Run], and [Invalidate].
type Executor struct {
	reportOptions report.Options

	// The lock implements singleflight for task execution and dependency tracking.
	// deps is used for cycle detection and transitive error collection.
	// parents is used for cache invalidation to transitively evict dependent tasks.
	lock    sync.Mutex
	tasks   map[any]*task
	deps    map[*task]map[*task]struct{}
	parents map[*task]map[*task]struct{}

	sema *semaphore.Weighted

	counter atomic.Uint64 // Used for generating sequence IDs for Result.Unchanged.
}

// ExecutorOption is an option func for [New].
type ExecutorOption func(*Executor)

// New constructs a new executor with the given maximum parallelism.
func New(options ...ExecutorOption) *Executor {
	exec := &Executor{
		sema: semaphore.NewWeighted(int64(runtime.GOMAXPROCS(0))),
	}

	for _, opt := range options {
		opt(exec)
	}

	return exec
}

// WithParallelism sets the maximum number of queries that can execute in
// parallel. Defaults to GOMAXPROCS if not set explicitly.
func WithParallelism(n int64) ExecutorOption {
	return func(e *Executor) { e.sema = semaphore.NewWeighted(n) }
}

// WithReportOptions sets the report options for reports generated by this
// executor.
func WithReportOptions(options report.Options) ExecutorOption {
	return func(e *Executor) { e.reportOptions = options }
}

// Keys returns a snapshot of the keys of which queries are present (and
// memoized) in an Executor.
//
// The returned slice is sorted.
func (e *Executor) Keys() (keys []string) {
	e.lock.Lock()
	defer e.lock.Unlock()
	keys = make([]string, 0, len(e.tasks))
	for key := range e.tasks {
		keys = append(keys, fmt.Sprintf("%#v", key))
	}
	slices.Sort(keys)
	return
}

var runExecutorKey byte

// Run executes a set of queries on this executor in parallel.
//
// This function only returns an error if ctx expires during execution,
// in which case it returns nil and [context.Cause].
//
// Errors that occur during each query are contained within the returned results.
// Unlike [Resolve], these contain the *transitive* errors for each query!
//
// Implementations of [Query].Execute MUST NOT UNDER ANY CIRCUMSTANCES call
// Run. This will result in potential resource starvation or deadlocking, and
// defeats other correctness verification (such as cycle detection). Instead,
// use [Resolve], which takes a [Task] instead of an [Executor].
//
// Note: this function really wants to be a method of [Executor], but it isn't
// because it's generic.
func Run[T any](ctx context.Context, e *Executor, queries ...Query[T]) ([]Result[T], *report.Report, error) {
	// Verify we haven't reëntrantly called Run.
	if callers, ok := ctx.Value(&runExecutorKey).(*[]*Executor); ok {
		if slices.Contains(*callers, e) {
			panic("protocompile/incremental: reentrant call to Run")
		}
		*callers = append(*callers, e)
	} else {
		ctx = context.WithValue(ctx, &runExecutorKey, &[]*Executor{e})
	}
	ctx, cancel := context.WithCancelCause(ctx)
	defer cancel(nil)

	generation := e.counter.Add(1)
	root := &Task{
		ctx:             ctx,
		cancel:          cancel,
		exec:            e,
		runID:           generation,
		onRootGoroutine: true,
	}

	// Need to acquire a hold on the global semaphore to represent the root
	// task we're about to execute.
	if !root.acquire() {
		return nil, nil, context.Cause(ctx)
	}
	defer root.release()

	results, tasks, expired := resolve(root, queries...)
	if expired != nil {
		if _, aborted := expired.(*errAbort); aborted {
			panic(expired)
		}
		return nil, nil, expired
	}
	// Record all diagnostics generates by the queries.
	report := &report.Report{Options: e.reportOptions}
	dedup := make(map[*task]struct{})
	for len(tasks) > 0 {
		dep := tasks[len(tasks)-1]
		if dep == nil {
			continue // Can happen due to an abort.
		}
		tasks = tasks[:len(tasks)-1]
		if _, ok := dedup[dep]; ok {
			continue
		}
		dedup[dep] = struct{}{}
		report.Diagnostics = append(report.Diagnostics, dep.report.Diagnostics...)
		for dep := range e.deps[dep] {
			tasks = append(tasks, dep)
		}
	}
	report.Canonicalize()
	return results, report, nil
}

// Evict marks query keys as invalid, requiring those queries, and their
// dependencies, to be recomputed. keys that are not cached are ignored.
//
// This function cannot execute in parallel with calls to [Run], and will take
// an exclusive lock (note that [Run] calls themselves can be run in parallel).
func (e *Executor) Evict(keys ...any) {
	e.lock.Lock()
	defer e.lock.Unlock()
	for len(keys) > 0 {
		key := keys[len(keys)-1]
		keys = keys[:len(keys)-1]
		if t, ok := e.tasks[key]; ok {
			for parent := range e.parents[t] {
				keys = append(keys, parent.query.Key())
			}
			delete(e.tasks, key)
			delete(e.deps, t)
			delete(e.parents, t)
		}
	}
}

func (e *Executor) addDependencyWithLock(parent *task, child *task) {
	if parent == nil {
		return // Root task.
	}
	parentDeps, ok := e.deps[parent]
	if !ok {
		parentDeps = make(map[*task]struct{}, 1)
		if e.deps == nil {
			e.deps = make(map[*task]map[*task]struct{})
			e.parents = make(map[*task]map[*task]struct{})
		}
		e.deps[parent] = parentDeps
	}
	childParents, ok := e.parents[child]
	if !ok {
		childParents = make(map[*task]struct{}, 1)
		e.parents[child] = childParents
	}
	parentDeps[child] = struct{}{}
	childParents[parent] = struct{}{}
}
