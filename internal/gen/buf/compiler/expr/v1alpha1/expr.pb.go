// Copyright 2020-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: buf/compiler/expr/v1alpha1/expr.proto

package exprv1alpha1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Brackets is one of the various known bracket types.
// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
type Brackets int32

const (
	Brackets_BRACKETS_NONE   Brackets = 0
	Brackets_BRACKETS_PARENS Brackets = 1
	Brackets_BRACKETS_SQUARE Brackets = 2
	Brackets_BRACKETS_CURLY  Brackets = 3
	Brackets_BRACKETS_ANGLE  Brackets = 4
)

// Enum value maps for Brackets.
var (
	Brackets_name = map[int32]string{
		0: "BRACKETS_NONE",
		1: "BRACKETS_PARENS",
		2: "BRACKETS_SQUARE",
		3: "BRACKETS_CURLY",
		4: "BRACKETS_ANGLE",
	}
	Brackets_value = map[string]int32{
		"BRACKETS_NONE":   0,
		"BRACKETS_PARENS": 1,
		"BRACKETS_SQUARE": 2,
		"BRACKETS_CURLY":  3,
		"BRACKETS_ANGLE":  4,
	}
)

func (x Brackets) Enum() *Brackets {
	p := new(Brackets)
	*p = x
	return p
}

func (x Brackets) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Brackets) Descriptor() protoreflect.EnumDescriptor {
	return file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes[0].Descriptor()
}

func (Brackets) Type() protoreflect.EnumType {
	return &file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes[0]
}

func (x Brackets) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Brackets.Descriptor instead.
func (Brackets) EnumDescriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{0}
}

// buf:lint:ignore ENUM_VALUE_PREFIX
type Control_Kind int32

const (
	Control_KIND_UNSPECIFIED Control_Kind = 0
	Control_RETURN           Control_Kind = 1
	Control_BREAK            Control_Kind = 2
	Control_CONTINUE         Control_Kind = 3
)

// Enum value maps for Control_Kind.
var (
	Control_Kind_name = map[int32]string{
		0: "KIND_UNSPECIFIED",
		1: "RETURN",
		2: "BREAK",
		3: "CONTINUE",
	}
	Control_Kind_value = map[string]int32{
		"KIND_UNSPECIFIED": 0,
		"RETURN":           1,
		"BREAK":            2,
		"CONTINUE":         3,
	}
)

func (x Control_Kind) Enum() *Control_Kind {
	p := new(Control_Kind)
	*p = x
	return p
}

func (x Control_Kind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Control_Kind) Descriptor() protoreflect.EnumDescriptor {
	return file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes[1].Descriptor()
}

func (Control_Kind) Type() protoreflect.EnumType {
	return &file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes[1]
}

func (x Control_Kind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Control_Kind.Descriptor instead.
func (Control_Kind) EnumDescriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{3, 0}
}

// buf:lint:ignore ENUM_VALUE_PREFIX
type Op_Kind int32

const (
	Op_KIND_UNSPECIFIED Op_Kind = 0
	Op_ASSIGN           Op_Kind = 1
	Op_ASSIGN_NEW       Op_Kind = 2
	Op_ASSIGN_ADD       Op_Kind = 3
	Op_ASSIGN_SUB       Op_Kind = 4
	Op_ASSIGN_MUL       Op_Kind = 5
	Op_ASSIGN_DIV       Op_Kind = 6
	Op_ASSIGN_REM       Op_Kind = 7
	Op_COMMA            Op_Kind = 8
	Op_OR               Op_Kind = 9
	Op_AND              Op_Kind = 10
	Op_NOT              Op_Kind = 11
	Op_EQ               Op_Kind = 12
	Op_NE               Op_Kind = 13
	Op_LT               Op_Kind = 14
	Op_GT               Op_Kind = 15
	Op_LE               Op_Kind = 16
	Op_GE               Op_Kind = 17
	Op_RANGE            Op_Kind = 18
	Op_RANGE_EQ         Op_Kind = 19
	Op_TO               Op_Kind = 20
	Op_ADD              Op_Kind = 21
	Op_SUB              Op_Kind = 22
	Op_MUL              Op_Kind = 23
	Op_DIV              Op_Kind = 24
	Op_REM              Op_Kind = 25
	Op_PROPERTY         Op_Kind = 26
)

// Enum value maps for Op_Kind.
var (
	Op_Kind_name = map[int32]string{
		0:  "KIND_UNSPECIFIED",
		1:  "ASSIGN",
		2:  "ASSIGN_NEW",
		3:  "ASSIGN_ADD",
		4:  "ASSIGN_SUB",
		5:  "ASSIGN_MUL",
		6:  "ASSIGN_DIV",
		7:  "ASSIGN_REM",
		8:  "COMMA",
		9:  "OR",
		10: "AND",
		11: "NOT",
		12: "EQ",
		13: "NE",
		14: "LT",
		15: "GT",
		16: "LE",
		17: "GE",
		18: "RANGE",
		19: "RANGE_EQ",
		20: "TO",
		21: "ADD",
		22: "SUB",
		23: "MUL",
		24: "DIV",
		25: "REM",
		26: "PROPERTY",
	}
	Op_Kind_value = map[string]int32{
		"KIND_UNSPECIFIED": 0,
		"ASSIGN":           1,
		"ASSIGN_NEW":       2,
		"ASSIGN_ADD":       3,
		"ASSIGN_SUB":       4,
		"ASSIGN_MUL":       5,
		"ASSIGN_DIV":       6,
		"ASSIGN_REM":       7,
		"COMMA":            8,
		"OR":               9,
		"AND":              10,
		"NOT":              11,
		"EQ":               12,
		"NE":               13,
		"LT":               14,
		"GT":               15,
		"LE":               16,
		"GE":               17,
		"RANGE":            18,
		"RANGE_EQ":         19,
		"TO":               20,
		"ADD":              21,
		"SUB":              22,
		"MUL":              23,
		"DIV":              24,
		"REM":              25,
		"PROPERTY":         26,
	}
)

func (x Op_Kind) Enum() *Op_Kind {
	p := new(Op_Kind)
	*p = x
	return p
}

func (x Op_Kind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Op_Kind) Descriptor() protoreflect.EnumDescriptor {
	return file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes[2].Descriptor()
}

func (Op_Kind) Type() protoreflect.EnumType {
	return &file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes[2]
}

func (x Op_Kind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Op_Kind.Descriptor instead.
func (Op_Kind) EnumDescriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{7, 0}
}

// An expression parsed from some file.
type Expr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Expr:
	//
	//	*Expr_Block
	//	*Expr_Call
	//	*Expr_Control
	//	*Expr_For
	//	*Expr_Func
	//	*Expr_If
	//	*Expr_Op
	//	*Expr_Record
	//	*Expr_Switch
	//	*Expr_Token
	Expr          isExpr_Expr `protobuf_oneof:"expr"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Expr) Reset() {
	*x = Expr{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Expr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Expr) ProtoMessage() {}

func (x *Expr) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Expr.ProtoReflect.Descriptor instead.
func (*Expr) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{0}
}

func (x *Expr) GetExpr() isExpr_Expr {
	if x != nil {
		return x.Expr
	}
	return nil
}

func (x *Expr) GetBlock() *Block {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Block); ok {
			return x.Block
		}
	}
	return nil
}

func (x *Expr) GetCall() *Call {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Call); ok {
			return x.Call
		}
	}
	return nil
}

func (x *Expr) GetControl() *Control {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Control); ok {
			return x.Control
		}
	}
	return nil
}

func (x *Expr) GetFor() *For {
	if x != nil {
		if x, ok := x.Expr.(*Expr_For); ok {
			return x.For
		}
	}
	return nil
}

func (x *Expr) GetFunc() *Func {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Func); ok {
			return x.Func
		}
	}
	return nil
}

func (x *Expr) GetIf() *If {
	if x != nil {
		if x, ok := x.Expr.(*Expr_If); ok {
			return x.If
		}
	}
	return nil
}

func (x *Expr) GetOp() *Op {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Op); ok {
			return x.Op
		}
	}
	return nil
}

func (x *Expr) GetRecord() *Params {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Record); ok {
			return x.Record
		}
	}
	return nil
}

func (x *Expr) GetSwitch() *Switch {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Switch); ok {
			return x.Switch
		}
	}
	return nil
}

func (x *Expr) GetToken() *Token {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Token); ok {
			return x.Token
		}
	}
	return nil
}

type isExpr_Expr interface {
	isExpr_Expr()
}

type Expr_Block struct {
	Block *Block `protobuf:"bytes,1,opt,name=block,proto3,oneof"`
}

type Expr_Call struct {
	Call *Call `protobuf:"bytes,2,opt,name=call,proto3,oneof"`
}

type Expr_Control struct {
	Control *Control `protobuf:"bytes,3,opt,name=control,proto3,oneof"`
}

type Expr_For struct {
	For *For `protobuf:"bytes,4,opt,name=for,proto3,oneof"`
}

type Expr_Func struct {
	Func *Func `protobuf:"bytes,5,opt,name=func,proto3,oneof"`
}

type Expr_If struct {
	If *If `protobuf:"bytes,6,opt,name=if,proto3,oneof"`
}

type Expr_Op struct {
	Op *Op `protobuf:"bytes,7,opt,name=op,proto3,oneof"`
}

type Expr_Record struct {
	Record *Params `protobuf:"bytes,8,opt,name=record,proto3,oneof"`
}

type Expr_Switch struct {
	Switch *Switch `protobuf:"bytes,9,opt,name=switch,proto3,oneof"`
}

type Expr_Token struct {
	Token *Token `protobuf:"bytes,10,opt,name=token,proto3,oneof"`
}

func (*Expr_Block) isExpr_Expr() {}

func (*Expr_Call) isExpr_Expr() {}

func (*Expr_Control) isExpr_Expr() {}

func (*Expr_For) isExpr_Expr() {}

func (*Expr_Func) isExpr_Expr() {}

func (*Expr_If) isExpr_Expr() {}

func (*Expr_Op) isExpr_Expr() {}

func (*Expr_Record) isExpr_Expr() {}

func (*Expr_Switch) isExpr_Expr() {}

func (*Expr_Token) isExpr_Expr() {}

// An expr.Block.
type Block struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Exprs         []*Expr                `protobuf:"bytes,1,rep,name=exprs,proto3" json:"exprs,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Block) Reset() {
	*x = Block{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Block) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Block) ProtoMessage() {}

func (x *Block) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Block.ProtoReflect.Descriptor instead.
func (*Block) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{1}
}

func (x *Block) GetExprs() []*Expr {
	if x != nil {
		return x.Exprs
	}
	return nil
}

func (x *Block) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

// An expr.Call.
type Call struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Callee        *Expr                  `protobuf:"bytes,1,opt,name=callee,proto3" json:"callee,omitempty"`
	Params        *Params                `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Call) Reset() {
	*x = Call{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Call) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Call) ProtoMessage() {}

func (x *Call) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Call.ProtoReflect.Descriptor instead.
func (*Call) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{2}
}

func (x *Call) GetCallee() *Expr {
	if x != nil {
		return x.Callee
	}
	return nil
}

func (x *Call) GetParams() *Params {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *Call) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

// An expr.Control.
type Control struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Kind          Control_Kind           `protobuf:"varint,1,opt,name=kind,proto3,enum=buf.compiler.expr.v1alpha1.Control_Kind" json:"kind,omitempty"`
	Args          *Params                `protobuf:"bytes,2,opt,name=args,proto3" json:"args,omitempty"`
	Cond          *Expr                  `protobuf:"bytes,3,opt,name=cond,proto3" json:"cond,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	KwSpan        *Span                  `protobuf:"bytes,11,opt,name=kw_span,json=kwSpan,proto3" json:"kw_span,omitempty"`
	IfSpan        *Span                  `protobuf:"bytes,12,opt,name=if_span,json=ifSpan,proto3" json:"if_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Control) Reset() {
	*x = Control{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Control) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Control) ProtoMessage() {}

func (x *Control) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Control.ProtoReflect.Descriptor instead.
func (*Control) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{3}
}

func (x *Control) GetKind() Control_Kind {
	if x != nil {
		return x.Kind
	}
	return Control_KIND_UNSPECIFIED
}

func (x *Control) GetArgs() *Params {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *Control) GetCond() *Expr {
	if x != nil {
		return x.Cond
	}
	return nil
}

func (x *Control) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *Control) GetKwSpan() *Span {
	if x != nil {
		return x.KwSpan
	}
	return nil
}

func (x *Control) GetIfSpan() *Span {
	if x != nil {
		return x.IfSpan
	}
	return nil
}

// An expr.For.
type For struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vars          *Params                `protobuf:"bytes,1,opt,name=vars,proto3" json:"vars,omitempty"`
	Iter          *Expr                  `protobuf:"bytes,2,opt,name=iter,proto3" json:"iter,omitempty"`
	Block         *Block                 `protobuf:"bytes,3,opt,name=block,proto3" json:"block,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	ForSpan       *Span                  `protobuf:"bytes,11,opt,name=for_span,json=forSpan,proto3" json:"for_span,omitempty"`
	InSpan        *Span                  `protobuf:"bytes,12,opt,name=in_span,json=inSpan,proto3" json:"in_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *For) Reset() {
	*x = For{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *For) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*For) ProtoMessage() {}

func (x *For) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use For.ProtoReflect.Descriptor instead.
func (*For) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{4}
}

func (x *For) GetVars() *Params {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *For) GetIter() *Expr {
	if x != nil {
		return x.Iter
	}
	return nil
}

func (x *For) GetBlock() *Block {
	if x != nil {
		return x.Block
	}
	return nil
}

func (x *For) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *For) GetForSpan() *Span {
	if x != nil {
		return x.ForSpan
	}
	return nil
}

func (x *For) GetInSpan() *Span {
	if x != nil {
		return x.InSpan
	}
	return nil
}

type Func struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Params        *Params                `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
	Return        *Expr                  `protobuf:"bytes,3,opt,name=return,proto3" json:"return,omitempty"`
	Body          *Expr                  `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	FuncSpan      *Span                  `protobuf:"bytes,11,opt,name=func_span,json=funcSpan,proto3" json:"func_span,omitempty"`
	NameSpan      *Span                  `protobuf:"bytes,12,opt,name=name_span,json=nameSpan,proto3" json:"name_span,omitempty"`
	ArrowSpan     *Span                  `protobuf:"bytes,13,opt,name=arrow_span,json=arrowSpan,proto3" json:"arrow_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Func) Reset() {
	*x = Func{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Func) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Func) ProtoMessage() {}

func (x *Func) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Func.ProtoReflect.Descriptor instead.
func (*Func) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{5}
}

func (x *Func) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Func) GetParams() *Params {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *Func) GetReturn() *Expr {
	if x != nil {
		return x.Return
	}
	return nil
}

func (x *Func) GetBody() *Expr {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *Func) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *Func) GetFuncSpan() *Span {
	if x != nil {
		return x.FuncSpan
	}
	return nil
}

func (x *Func) GetNameSpan() *Span {
	if x != nil {
		return x.NameSpan
	}
	return nil
}

func (x *Func) GetArrowSpan() *Span {
	if x != nil {
		return x.ArrowSpan
	}
	return nil
}

// An expr.If.
type If struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cond          *Expr                  `protobuf:"bytes,1,opt,name=cond,proto3" json:"cond,omitempty"`
	Block         *Block                 `protobuf:"bytes,2,opt,name=block,proto3" json:"block,omitempty"`
	Else          *If                    `protobuf:"bytes,3,opt,name=else,proto3" json:"else,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	ElseSpan      *Span                  `protobuf:"bytes,11,opt,name=else_span,json=elseSpan,proto3" json:"else_span,omitempty"`
	IfSpan        *Span                  `protobuf:"bytes,12,opt,name=if_span,json=ifSpan,proto3" json:"if_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *If) Reset() {
	*x = If{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *If) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*If) ProtoMessage() {}

func (x *If) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use If.ProtoReflect.Descriptor instead.
func (*If) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{6}
}

func (x *If) GetCond() *Expr {
	if x != nil {
		return x.Cond
	}
	return nil
}

func (x *If) GetBlock() *Block {
	if x != nil {
		return x.Block
	}
	return nil
}

func (x *If) GetElse() *If {
	if x != nil {
		return x.Else
	}
	return nil
}

func (x *If) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *If) GetElseSpan() *Span {
	if x != nil {
		return x.ElseSpan
	}
	return nil
}

func (x *If) GetIfSpan() *Span {
	if x != nil {
		return x.IfSpan
	}
	return nil
}

// An expr.Op.
type Op struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	Op            Op_Kind                `protobuf:"varint,3,opt,name=op,proto3,enum=buf.compiler.expr.v1alpha1.Op_Kind" json:"op,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	OpSpan        *Span                  `protobuf:"bytes,11,opt,name=op_span,json=opSpan,proto3" json:"op_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Op) Reset() {
	*x = Op{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Op) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Op) ProtoMessage() {}

func (x *Op) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Op.ProtoReflect.Descriptor instead.
func (*Op) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{7}
}

func (x *Op) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *Op) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

func (x *Op) GetOp() Op_Kind {
	if x != nil {
		return x.Op
	}
	return Op_KIND_UNSPECIFIED
}

func (x *Op) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *Op) GetOpSpan() *Span {
	if x != nil {
		return x.OpSpan
	}
	return nil
}

// An expr.Switch.
type Switch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Arg           *Expr                  `protobuf:"bytes,1,opt,name=arg,proto3" json:"arg,omitempty"`
	Cases         []*Switch_Case         `protobuf:"bytes,2,rep,name=cases,proto3" json:"cases,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	SwitchSpan    *Span                  `protobuf:"bytes,11,opt,name=switch_span,json=switchSpan,proto3" json:"switch_span,omitempty"`
	BlockSpan     *Span                  `protobuf:"bytes,12,opt,name=block_span,json=blockSpan,proto3" json:"block_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Switch) Reset() {
	*x = Switch{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Switch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Switch) ProtoMessage() {}

func (x *Switch) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Switch.ProtoReflect.Descriptor instead.
func (*Switch) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{8}
}

func (x *Switch) GetArg() *Expr {
	if x != nil {
		return x.Arg
	}
	return nil
}

func (x *Switch) GetCases() []*Switch_Case {
	if x != nil {
		return x.Cases
	}
	return nil
}

func (x *Switch) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *Switch) GetSwitchSpan() *Span {
	if x != nil {
		return x.SwitchSpan
	}
	return nil
}

func (x *Switch) GetBlockSpan() *Span {
	if x != nil {
		return x.BlockSpan
	}
	return nil
}

// An expr.Token.
type Token struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// None of these may be set, in the case of an invalid value.
	//
	// Types that are valid to be assigned to Value:
	//
	//	*Token_Int
	//	*Token_Float
	//	*Token_String_
	//	*Token_Ident
	Value         isToken_Value `protobuf_oneof:"value"`
	Span          *Span         `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Token) Reset() {
	*x = Token{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Token) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Token) ProtoMessage() {}

func (x *Token) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Token.ProtoReflect.Descriptor instead.
func (*Token) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{9}
}

func (x *Token) GetValue() isToken_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Token) GetInt() uint64 {
	if x != nil {
		if x, ok := x.Value.(*Token_Int); ok {
			return x.Int
		}
	}
	return 0
}

func (x *Token) GetFloat() float64 {
	if x != nil {
		if x, ok := x.Value.(*Token_Float); ok {
			return x.Float
		}
	}
	return 0
}

func (x *Token) GetString_() string {
	if x != nil {
		if x, ok := x.Value.(*Token_String_); ok {
			return x.String_
		}
	}
	return ""
}

func (x *Token) GetIdent() string {
	if x != nil {
		if x, ok := x.Value.(*Token_Ident); ok {
			return x.Ident
		}
	}
	return ""
}

func (x *Token) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

type isToken_Value interface {
	isToken_Value()
}

type Token_Int struct {
	Int uint64 `protobuf:"varint,1,opt,name=int,proto3,oneof"`
}

type Token_Float struct {
	Float float64 `protobuf:"fixed64,2,opt,name=float,proto3,oneof"`
}

type Token_String_ struct {
	String_ string `protobuf:"bytes,3,opt,name=string,proto3,oneof"`
}

type Token_Ident struct {
	Ident string `protobuf:"bytes,4,opt,name=ident,proto3,oneof"`
}

func (*Token_Int) isToken_Value() {}

func (*Token_Float) isToken_Value() {}

func (*Token_String_) isToken_Value() {}

func (*Token_Ident) isToken_Value() {}

// An expr.Params.
type Params struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Brackets      Brackets               `protobuf:"varint,1,opt,name=brackets,proto3,enum=buf.compiler.expr.v1alpha1.Brackets" json:"brackets,omitempty"`
	Params        []*Params_Param        `protobuf:"bytes,2,rep,name=params,proto3" json:"params,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Params) Reset() {
	*x = Params{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Params) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Params) ProtoMessage() {}

func (x *Params) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Params.ProtoReflect.Descriptor instead.
func (*Params) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{10}
}

func (x *Params) GetBrackets() Brackets {
	if x != nil {
		return x.Brackets
	}
	return Brackets_BRACKETS_NONE
}

func (x *Params) GetParams() []*Params_Param {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *Params) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

// A source code span for a specific `File`.
//
// This only contains byte offsets for the span; all other information
// (such as the line number) should be re-computed as needed.
type Span struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         uint32                 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End           uint32                 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Span) Reset() {
	*x = Span{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Span) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Span) ProtoMessage() {}

func (x *Span) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Span.ProtoReflect.Descriptor instead.
func (*Span) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{11}
}

func (x *Span) GetStart() uint32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Span) GetEnd() uint32 {
	if x != nil {
		return x.End
	}
	return 0
}

type Switch_Case struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Else          bool                   `protobuf:"varint,1,opt,name=else,proto3" json:"else,omitempty"`
	Alts          *Params                `protobuf:"bytes,2,opt,name=alts,proto3" json:"alts,omitempty"`
	Block         *Block                 `protobuf:"bytes,3,opt,name=block,proto3" json:"block,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	KwSpan        *Span                  `protobuf:"bytes,11,opt,name=kw_span,json=kwSpan,proto3" json:"kw_span,omitempty"`
	ColonSpan     *Span                  `protobuf:"bytes,12,opt,name=colon_span,json=colonSpan,proto3" json:"colon_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Switch_Case) Reset() {
	*x = Switch_Case{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Switch_Case) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Switch_Case) ProtoMessage() {}

func (x *Switch_Case) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Switch_Case.ProtoReflect.Descriptor instead.
func (*Switch_Case) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{8, 0}
}

func (x *Switch_Case) GetElse() bool {
	if x != nil {
		return x.Else
	}
	return false
}

func (x *Switch_Case) GetAlts() *Params {
	if x != nil {
		return x.Alts
	}
	return nil
}

func (x *Switch_Case) GetBlock() *Block {
	if x != nil {
		return x.Block
	}
	return nil
}

func (x *Switch_Case) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *Switch_Case) GetKwSpan() *Span {
	if x != nil {
		return x.KwSpan
	}
	return nil
}

func (x *Switch_Case) GetColonSpan() *Span {
	if x != nil {
		return x.ColonSpan
	}
	return nil
}

type Params_Param struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          *Expr                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Expr          *Expr                  `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	Cond          *Expr                  `protobuf:"bytes,3,opt,name=cond,proto3" json:"cond,omitempty"`
	Span          *Span                  `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	ColonSpan     *Span                  `protobuf:"bytes,11,opt,name=colon_span,json=colonSpan,proto3" json:"colon_span,omitempty"`
	IfSpan        *Span                  `protobuf:"bytes,12,opt,name=if_span,json=ifSpan,proto3" json:"if_span,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Params_Param) Reset() {
	*x = Params_Param{}
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Params_Param) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Params_Param) ProtoMessage() {}

func (x *Params_Param) ProtoReflect() protoreflect.Message {
	mi := &file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Params_Param.ProtoReflect.Descriptor instead.
func (*Params_Param) Descriptor() ([]byte, []int) {
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP(), []int{10, 0}
}

func (x *Params_Param) GetName() *Expr {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Params_Param) GetExpr() *Expr {
	if x != nil {
		return x.Expr
	}
	return nil
}

func (x *Params_Param) GetCond() *Expr {
	if x != nil {
		return x.Cond
	}
	return nil
}

func (x *Params_Param) GetSpan() *Span {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *Params_Param) GetColonSpan() *Span {
	if x != nil {
		return x.ColonSpan
	}
	return nil
}

func (x *Params_Param) GetIfSpan() *Span {
	if x != nil {
		return x.IfSpan
	}
	return nil
}

var File_buf_compiler_expr_v1alpha1_expr_proto protoreflect.FileDescriptor

const file_buf_compiler_expr_v1alpha1_expr_proto_rawDesc = "" +
	"\n" +
	"%buf/compiler/expr/v1alpha1/expr.proto\x12\x1abuf.compiler.expr.v1alpha1\"\xca\x04\n" +
	"\x04Expr\x129\n" +
	"\x05block\x18\x01 \x01(\v2!.buf.compiler.expr.v1alpha1.BlockH\x00R\x05block\x126\n" +
	"\x04call\x18\x02 \x01(\v2 .buf.compiler.expr.v1alpha1.CallH\x00R\x04call\x12?\n" +
	"\acontrol\x18\x03 \x01(\v2#.buf.compiler.expr.v1alpha1.ControlH\x00R\acontrol\x123\n" +
	"\x03for\x18\x04 \x01(\v2\x1f.buf.compiler.expr.v1alpha1.ForH\x00R\x03for\x126\n" +
	"\x04func\x18\x05 \x01(\v2 .buf.compiler.expr.v1alpha1.FuncH\x00R\x04func\x120\n" +
	"\x02if\x18\x06 \x01(\v2\x1e.buf.compiler.expr.v1alpha1.IfH\x00R\x02if\x120\n" +
	"\x02op\x18\a \x01(\v2\x1e.buf.compiler.expr.v1alpha1.OpH\x00R\x02op\x12<\n" +
	"\x06record\x18\b \x01(\v2\".buf.compiler.expr.v1alpha1.ParamsH\x00R\x06record\x12<\n" +
	"\x06switch\x18\t \x01(\v2\".buf.compiler.expr.v1alpha1.SwitchH\x00R\x06switch\x129\n" +
	"\x05token\x18\n" +
	" \x01(\v2!.buf.compiler.expr.v1alpha1.TokenH\x00R\x05tokenB\x06\n" +
	"\x04expr\"u\n" +
	"\x05Block\x126\n" +
	"\x05exprs\x18\x01 \x03(\v2 .buf.compiler.expr.v1alpha1.ExprR\x05exprs\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\"\xb2\x01\n" +
	"\x04Call\x128\n" +
	"\x06callee\x18\x01 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x06callee\x12:\n" +
	"\x06params\x18\x02 \x01(\v2\".buf.compiler.expr.v1alpha1.ParamsR\x06params\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\"\xa4\x03\n" +
	"\aControl\x12<\n" +
	"\x04kind\x18\x01 \x01(\x0e2(.buf.compiler.expr.v1alpha1.Control.KindR\x04kind\x126\n" +
	"\x04args\x18\x02 \x01(\v2\".buf.compiler.expr.v1alpha1.ParamsR\x04args\x124\n" +
	"\x04cond\x18\x03 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04cond\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x129\n" +
	"\akw_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x06kwSpan\x129\n" +
	"\aif_span\x18\f \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x06ifSpan\"A\n" +
	"\x04Kind\x12\x14\n" +
	"\x10KIND_UNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06RETURN\x10\x01\x12\t\n" +
	"\x05BREAK\x10\x02\x12\f\n" +
	"\bCONTINUE\x10\x03\"\xda\x02\n" +
	"\x03For\x126\n" +
	"\x04vars\x18\x01 \x01(\v2\".buf.compiler.expr.v1alpha1.ParamsR\x04vars\x124\n" +
	"\x04iter\x18\x02 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04iter\x127\n" +
	"\x05block\x18\x03 \x01(\v2!.buf.compiler.expr.v1alpha1.BlockR\x05block\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x12;\n" +
	"\bfor_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\aforSpan\x129\n" +
	"\ain_span\x18\f \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x06inSpan\"\xbb\x03\n" +
	"\x04Func\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12:\n" +
	"\x06params\x18\x02 \x01(\v2\".buf.compiler.expr.v1alpha1.ParamsR\x06params\x128\n" +
	"\x06return\x18\x03 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x06return\x124\n" +
	"\x04body\x18\x04 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04body\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x12=\n" +
	"\tfunc_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\bfuncSpan\x12=\n" +
	"\tname_span\x18\f \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\bnameSpan\x12?\n" +
	"\n" +
	"arrow_span\x18\r \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\tarrowSpan\"\xd7\x02\n" +
	"\x02If\x124\n" +
	"\x04cond\x18\x01 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04cond\x127\n" +
	"\x05block\x18\x02 \x01(\v2!.buf.compiler.expr.v1alpha1.BlockR\x05block\x122\n" +
	"\x04else\x18\x03 \x01(\v2\x1e.buf.compiler.expr.v1alpha1.IfR\x04else\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x12=\n" +
	"\telse_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\belseSpan\x129\n" +
	"\aif_span\x18\f \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x06ifSpan\"\xd4\x04\n" +
	"\x02Op\x124\n" +
	"\x04left\x18\x01 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04left\x126\n" +
	"\x05right\x18\x02 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x05right\x123\n" +
	"\x02op\x18\x03 \x01(\x0e2#.buf.compiler.expr.v1alpha1.Op.KindR\x02op\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x129\n" +
	"\aop_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x06opSpan\"\xb9\x02\n" +
	"\x04Kind\x12\x14\n" +
	"\x10KIND_UNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06ASSIGN\x10\x01\x12\x0e\n" +
	"\n" +
	"ASSIGN_NEW\x10\x02\x12\x0e\n" +
	"\n" +
	"ASSIGN_ADD\x10\x03\x12\x0e\n" +
	"\n" +
	"ASSIGN_SUB\x10\x04\x12\x0e\n" +
	"\n" +
	"ASSIGN_MUL\x10\x05\x12\x0e\n" +
	"\n" +
	"ASSIGN_DIV\x10\x06\x12\x0e\n" +
	"\n" +
	"ASSIGN_REM\x10\a\x12\t\n" +
	"\x05COMMA\x10\b\x12\x06\n" +
	"\x02OR\x10\t\x12\a\n" +
	"\x03AND\x10\n" +
	"\x12\a\n" +
	"\x03NOT\x10\v\x12\x06\n" +
	"\x02EQ\x10\f\x12\x06\n" +
	"\x02NE\x10\r\x12\x06\n" +
	"\x02LT\x10\x0e\x12\x06\n" +
	"\x02GT\x10\x0f\x12\x06\n" +
	"\x02LE\x10\x10\x12\x06\n" +
	"\x02GE\x10\x11\x12\t\n" +
	"\x05RANGE\x10\x12\x12\f\n" +
	"\bRANGE_EQ\x10\x13\x12\x06\n" +
	"\x02TO\x10\x14\x12\a\n" +
	"\x03ADD\x10\x15\x12\a\n" +
	"\x03SUB\x10\x16\x12\a\n" +
	"\x03MUL\x10\x17\x12\a\n" +
	"\x03DIV\x10\x18\x12\a\n" +
	"\x03REM\x10\x19\x12\f\n" +
	"\bPROPERTY\x10\x1a\"\xf5\x04\n" +
	"\x06Switch\x122\n" +
	"\x03arg\x18\x01 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x03arg\x12=\n" +
	"\x05cases\x18\x02 \x03(\v2'.buf.compiler.expr.v1alpha1.Switch.CaseR\x05cases\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x12A\n" +
	"\vswitch_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\n" +
	"switchSpan\x12?\n" +
	"\n" +
	"block_span\x18\f \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\tblockSpan\x1a\xbd\x02\n" +
	"\x04Case\x12\x12\n" +
	"\x04else\x18\x01 \x01(\bR\x04else\x126\n" +
	"\x04alts\x18\x02 \x01(\v2\".buf.compiler.expr.v1alpha1.ParamsR\x04alts\x127\n" +
	"\x05block\x18\x03 \x01(\v2!.buf.compiler.expr.v1alpha1.BlockR\x05block\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x129\n" +
	"\akw_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x06kwSpan\x12?\n" +
	"\n" +
	"colon_span\x18\f \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\tcolonSpan\"\xa4\x01\n" +
	"\x05Token\x12\x12\n" +
	"\x03int\x18\x01 \x01(\x04H\x00R\x03int\x12\x16\n" +
	"\x05float\x18\x02 \x01(\x01H\x00R\x05float\x12\x18\n" +
	"\x06string\x18\x03 \x01(\tH\x00R\x06string\x12\x16\n" +
	"\x05ident\x18\x04 \x01(\tH\x00R\x05ident\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04spanB\a\n" +
	"\x05value\"\xa0\x04\n" +
	"\x06Params\x12@\n" +
	"\bbrackets\x18\x01 \x01(\x0e2$.buf.compiler.expr.v1alpha1.BracketsR\bbrackets\x12@\n" +
	"\x06params\x18\x02 \x03(\v2(.buf.compiler.expr.v1alpha1.Params.ParamR\x06params\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x1a\xdb\x02\n" +
	"\x05Param\x124\n" +
	"\x04name\x18\x01 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04name\x124\n" +
	"\x04expr\x18\x02 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04expr\x124\n" +
	"\x04cond\x18\x03 \x01(\v2 .buf.compiler.expr.v1alpha1.ExprR\x04cond\x124\n" +
	"\x04span\x18\n" +
	" \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x04span\x12?\n" +
	"\n" +
	"colon_span\x18\v \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\tcolonSpan\x129\n" +
	"\aif_span\x18\f \x01(\v2 .buf.compiler.expr.v1alpha1.SpanR\x06ifSpan\".\n" +
	"\x04Span\x12\x14\n" +
	"\x05start\x18\x01 \x01(\rR\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\rR\x03end*o\n" +
	"\bBrackets\x12\x11\n" +
	"\rBRACKETS_NONE\x10\x00\x12\x13\n" +
	"\x0fBRACKETS_PARENS\x10\x01\x12\x13\n" +
	"\x0fBRACKETS_SQUARE\x10\x02\x12\x12\n" +
	"\x0eBRACKETS_CURLY\x10\x03\x12\x12\n" +
	"\x0eBRACKETS_ANGLE\x10\x04B\x8d\x02\n" +
	"\x1ecom.buf.compiler.expr.v1alpha1B\tExprProtoP\x01ZUgithub.com/bufbuild/protocompile/internal/gen/buf/compiler/expr/v1alpha1;exprv1alpha1\xa2\x02\x03BCE\xaa\x02\x1aBuf.Compiler.Expr.V1alpha1\xca\x02\x1aBuf\\Compiler\\Expr\\V1alpha1\xe2\x02&Buf\\Compiler\\Expr\\V1alpha1\\GPBMetadata\xea\x02\x1dBuf::Compiler::Expr::V1alpha1b\x06proto3"

var (
	file_buf_compiler_expr_v1alpha1_expr_proto_rawDescOnce sync.Once
	file_buf_compiler_expr_v1alpha1_expr_proto_rawDescData []byte
)

func file_buf_compiler_expr_v1alpha1_expr_proto_rawDescGZIP() []byte {
	file_buf_compiler_expr_v1alpha1_expr_proto_rawDescOnce.Do(func() {
		file_buf_compiler_expr_v1alpha1_expr_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_buf_compiler_expr_v1alpha1_expr_proto_rawDesc), len(file_buf_compiler_expr_v1alpha1_expr_proto_rawDesc)))
	})
	return file_buf_compiler_expr_v1alpha1_expr_proto_rawDescData
}

var file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_buf_compiler_expr_v1alpha1_expr_proto_goTypes = []any{
	(Brackets)(0),        // 0: buf.compiler.expr.v1alpha1.Brackets
	(Control_Kind)(0),    // 1: buf.compiler.expr.v1alpha1.Control.Kind
	(Op_Kind)(0),         // 2: buf.compiler.expr.v1alpha1.Op.Kind
	(*Expr)(nil),         // 3: buf.compiler.expr.v1alpha1.Expr
	(*Block)(nil),        // 4: buf.compiler.expr.v1alpha1.Block
	(*Call)(nil),         // 5: buf.compiler.expr.v1alpha1.Call
	(*Control)(nil),      // 6: buf.compiler.expr.v1alpha1.Control
	(*For)(nil),          // 7: buf.compiler.expr.v1alpha1.For
	(*Func)(nil),         // 8: buf.compiler.expr.v1alpha1.Func
	(*If)(nil),           // 9: buf.compiler.expr.v1alpha1.If
	(*Op)(nil),           // 10: buf.compiler.expr.v1alpha1.Op
	(*Switch)(nil),       // 11: buf.compiler.expr.v1alpha1.Switch
	(*Token)(nil),        // 12: buf.compiler.expr.v1alpha1.Token
	(*Params)(nil),       // 13: buf.compiler.expr.v1alpha1.Params
	(*Span)(nil),         // 14: buf.compiler.expr.v1alpha1.Span
	(*Switch_Case)(nil),  // 15: buf.compiler.expr.v1alpha1.Switch.Case
	(*Params_Param)(nil), // 16: buf.compiler.expr.v1alpha1.Params.Param
}
var file_buf_compiler_expr_v1alpha1_expr_proto_depIdxs = []int32{
	4,  // 0: buf.compiler.expr.v1alpha1.Expr.block:type_name -> buf.compiler.expr.v1alpha1.Block
	5,  // 1: buf.compiler.expr.v1alpha1.Expr.call:type_name -> buf.compiler.expr.v1alpha1.Call
	6,  // 2: buf.compiler.expr.v1alpha1.Expr.control:type_name -> buf.compiler.expr.v1alpha1.Control
	7,  // 3: buf.compiler.expr.v1alpha1.Expr.for:type_name -> buf.compiler.expr.v1alpha1.For
	8,  // 4: buf.compiler.expr.v1alpha1.Expr.func:type_name -> buf.compiler.expr.v1alpha1.Func
	9,  // 5: buf.compiler.expr.v1alpha1.Expr.if:type_name -> buf.compiler.expr.v1alpha1.If
	10, // 6: buf.compiler.expr.v1alpha1.Expr.op:type_name -> buf.compiler.expr.v1alpha1.Op
	13, // 7: buf.compiler.expr.v1alpha1.Expr.record:type_name -> buf.compiler.expr.v1alpha1.Params
	11, // 8: buf.compiler.expr.v1alpha1.Expr.switch:type_name -> buf.compiler.expr.v1alpha1.Switch
	12, // 9: buf.compiler.expr.v1alpha1.Expr.token:type_name -> buf.compiler.expr.v1alpha1.Token
	3,  // 10: buf.compiler.expr.v1alpha1.Block.exprs:type_name -> buf.compiler.expr.v1alpha1.Expr
	14, // 11: buf.compiler.expr.v1alpha1.Block.span:type_name -> buf.compiler.expr.v1alpha1.Span
	3,  // 12: buf.compiler.expr.v1alpha1.Call.callee:type_name -> buf.compiler.expr.v1alpha1.Expr
	13, // 13: buf.compiler.expr.v1alpha1.Call.params:type_name -> buf.compiler.expr.v1alpha1.Params
	14, // 14: buf.compiler.expr.v1alpha1.Call.span:type_name -> buf.compiler.expr.v1alpha1.Span
	1,  // 15: buf.compiler.expr.v1alpha1.Control.kind:type_name -> buf.compiler.expr.v1alpha1.Control.Kind
	13, // 16: buf.compiler.expr.v1alpha1.Control.args:type_name -> buf.compiler.expr.v1alpha1.Params
	3,  // 17: buf.compiler.expr.v1alpha1.Control.cond:type_name -> buf.compiler.expr.v1alpha1.Expr
	14, // 18: buf.compiler.expr.v1alpha1.Control.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 19: buf.compiler.expr.v1alpha1.Control.kw_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 20: buf.compiler.expr.v1alpha1.Control.if_span:type_name -> buf.compiler.expr.v1alpha1.Span
	13, // 21: buf.compiler.expr.v1alpha1.For.vars:type_name -> buf.compiler.expr.v1alpha1.Params
	3,  // 22: buf.compiler.expr.v1alpha1.For.iter:type_name -> buf.compiler.expr.v1alpha1.Expr
	4,  // 23: buf.compiler.expr.v1alpha1.For.block:type_name -> buf.compiler.expr.v1alpha1.Block
	14, // 24: buf.compiler.expr.v1alpha1.For.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 25: buf.compiler.expr.v1alpha1.For.for_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 26: buf.compiler.expr.v1alpha1.For.in_span:type_name -> buf.compiler.expr.v1alpha1.Span
	13, // 27: buf.compiler.expr.v1alpha1.Func.params:type_name -> buf.compiler.expr.v1alpha1.Params
	3,  // 28: buf.compiler.expr.v1alpha1.Func.return:type_name -> buf.compiler.expr.v1alpha1.Expr
	3,  // 29: buf.compiler.expr.v1alpha1.Func.body:type_name -> buf.compiler.expr.v1alpha1.Expr
	14, // 30: buf.compiler.expr.v1alpha1.Func.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 31: buf.compiler.expr.v1alpha1.Func.func_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 32: buf.compiler.expr.v1alpha1.Func.name_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 33: buf.compiler.expr.v1alpha1.Func.arrow_span:type_name -> buf.compiler.expr.v1alpha1.Span
	3,  // 34: buf.compiler.expr.v1alpha1.If.cond:type_name -> buf.compiler.expr.v1alpha1.Expr
	4,  // 35: buf.compiler.expr.v1alpha1.If.block:type_name -> buf.compiler.expr.v1alpha1.Block
	9,  // 36: buf.compiler.expr.v1alpha1.If.else:type_name -> buf.compiler.expr.v1alpha1.If
	14, // 37: buf.compiler.expr.v1alpha1.If.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 38: buf.compiler.expr.v1alpha1.If.else_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 39: buf.compiler.expr.v1alpha1.If.if_span:type_name -> buf.compiler.expr.v1alpha1.Span
	3,  // 40: buf.compiler.expr.v1alpha1.Op.left:type_name -> buf.compiler.expr.v1alpha1.Expr
	3,  // 41: buf.compiler.expr.v1alpha1.Op.right:type_name -> buf.compiler.expr.v1alpha1.Expr
	2,  // 42: buf.compiler.expr.v1alpha1.Op.op:type_name -> buf.compiler.expr.v1alpha1.Op.Kind
	14, // 43: buf.compiler.expr.v1alpha1.Op.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 44: buf.compiler.expr.v1alpha1.Op.op_span:type_name -> buf.compiler.expr.v1alpha1.Span
	3,  // 45: buf.compiler.expr.v1alpha1.Switch.arg:type_name -> buf.compiler.expr.v1alpha1.Expr
	15, // 46: buf.compiler.expr.v1alpha1.Switch.cases:type_name -> buf.compiler.expr.v1alpha1.Switch.Case
	14, // 47: buf.compiler.expr.v1alpha1.Switch.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 48: buf.compiler.expr.v1alpha1.Switch.switch_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 49: buf.compiler.expr.v1alpha1.Switch.block_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 50: buf.compiler.expr.v1alpha1.Token.span:type_name -> buf.compiler.expr.v1alpha1.Span
	0,  // 51: buf.compiler.expr.v1alpha1.Params.brackets:type_name -> buf.compiler.expr.v1alpha1.Brackets
	16, // 52: buf.compiler.expr.v1alpha1.Params.params:type_name -> buf.compiler.expr.v1alpha1.Params.Param
	14, // 53: buf.compiler.expr.v1alpha1.Params.span:type_name -> buf.compiler.expr.v1alpha1.Span
	13, // 54: buf.compiler.expr.v1alpha1.Switch.Case.alts:type_name -> buf.compiler.expr.v1alpha1.Params
	4,  // 55: buf.compiler.expr.v1alpha1.Switch.Case.block:type_name -> buf.compiler.expr.v1alpha1.Block
	14, // 56: buf.compiler.expr.v1alpha1.Switch.Case.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 57: buf.compiler.expr.v1alpha1.Switch.Case.kw_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 58: buf.compiler.expr.v1alpha1.Switch.Case.colon_span:type_name -> buf.compiler.expr.v1alpha1.Span
	3,  // 59: buf.compiler.expr.v1alpha1.Params.Param.name:type_name -> buf.compiler.expr.v1alpha1.Expr
	3,  // 60: buf.compiler.expr.v1alpha1.Params.Param.expr:type_name -> buf.compiler.expr.v1alpha1.Expr
	3,  // 61: buf.compiler.expr.v1alpha1.Params.Param.cond:type_name -> buf.compiler.expr.v1alpha1.Expr
	14, // 62: buf.compiler.expr.v1alpha1.Params.Param.span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 63: buf.compiler.expr.v1alpha1.Params.Param.colon_span:type_name -> buf.compiler.expr.v1alpha1.Span
	14, // 64: buf.compiler.expr.v1alpha1.Params.Param.if_span:type_name -> buf.compiler.expr.v1alpha1.Span
	65, // [65:65] is the sub-list for method output_type
	65, // [65:65] is the sub-list for method input_type
	65, // [65:65] is the sub-list for extension type_name
	65, // [65:65] is the sub-list for extension extendee
	0,  // [0:65] is the sub-list for field type_name
}

func init() { file_buf_compiler_expr_v1alpha1_expr_proto_init() }
func file_buf_compiler_expr_v1alpha1_expr_proto_init() {
	if File_buf_compiler_expr_v1alpha1_expr_proto != nil {
		return
	}
	file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[0].OneofWrappers = []any{
		(*Expr_Block)(nil),
		(*Expr_Call)(nil),
		(*Expr_Control)(nil),
		(*Expr_For)(nil),
		(*Expr_Func)(nil),
		(*Expr_If)(nil),
		(*Expr_Op)(nil),
		(*Expr_Record)(nil),
		(*Expr_Switch)(nil),
		(*Expr_Token)(nil),
	}
	file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes[9].OneofWrappers = []any{
		(*Token_Int)(nil),
		(*Token_Float)(nil),
		(*Token_String_)(nil),
		(*Token_Ident)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_buf_compiler_expr_v1alpha1_expr_proto_rawDesc), len(file_buf_compiler_expr_v1alpha1_expr_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_buf_compiler_expr_v1alpha1_expr_proto_goTypes,
		DependencyIndexes: file_buf_compiler_expr_v1alpha1_expr_proto_depIdxs,
		EnumInfos:         file_buf_compiler_expr_v1alpha1_expr_proto_enumTypes,
		MessageInfos:      file_buf_compiler_expr_v1alpha1_expr_proto_msgTypes,
	}.Build()
	File_buf_compiler_expr_v1alpha1_expr_proto = out.File
	file_buf_compiler_expr_v1alpha1_expr_proto_goTypes = nil
	file_buf_compiler_expr_v1alpha1_expr_proto_depIdxs = nil
}
