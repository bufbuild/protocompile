// Copyright 2020-2024 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// enum is a helper for generating boilerplate related to Go enums.
//
// To generate boilerplate for a given file, use
//
//	//go:generate go run github.com/bufbuild/protocompile/internal/enum
//
// To generate code for an enum type, annotate it with the appropriate
// directives.
//
//   - //enum:string Name will generate a stringifying methods named Name,
//     which default to "String".
//
//   - //enum:gostring Name is similar, but the default name is "GoString"
//     and each constant stringifies to "package.Constant".
//
//   - //enum:fromstring Name generates a function that takes a string and
//     returns the constant that stringifies to that value, or 0 if there is
//     no such value.
//
//   - //enum:doc directive "..." adds a line of doc comment to the method
//     generated by directive with the given text.
//
//   - //enum:import "..." will include a package to import in the generated
//     file.
//
//   - //enum:skip, attached to an enum constant, will cause that constant to
//     be ignored by the generator.
//
//   - //enum:stringfunc Name provides a function to use for stringifying
//     based on the name of a constant (see below).
//
// The string representation of an enum constant is computed by the following
// process:
//
//  1. If the constant is annotated with //enum:string "...", it will use that
//     value.
//
//  2. If the enum type is annotated with //enum:stringfunc Name, the string
//     will be Name("Constant"), where Constant is the Go-declared name of the
//     constant.
//
//  3. The string is "Constant".
package main

import (
	"debug/buildinfo"
	_ "embed"
	"fmt"
	"os"
	"slices"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type Enum struct {
	Name    string   `yaml:"name"`
	Type    string   `yaml:"type"`
	Docs    string   `yaml:"docs"`
	Methods []Method `yaml:"methods"`
	Values  []Value  `yaml:"values"`
}

type Value struct {
	Name    string `yaml:"name"`
	Alias   string `yaml:"alias"`
	String_ string `yaml:"string"`
	Docs    string `yaml:"docs"`
}

func (v Value) String() string {
	if v.String_ == "" {
		return v.Name
	}
	return v.String_
}

type Method struct {
	Kind  MethodKind `yaml:"kind"`
	Name_ string     `yaml:"name"`
	Docs_ string     `yaml:"docs"`
	Skip  []string   `yaml:"skip"`
}

func (m Method) Name() (string, error) {
	if m.Name_ != "" {
		return m.Name_, nil
	}

	switch m.Kind {
	case MethodFromString:
		return "", fmt.Errorf("missing name for kind: %#v", MethodFromString)
	case MethodGoString:
		return "GoString", nil
	case MethodString:
		return "String", nil
	default:
		return "", fmt.Errorf("unexpected kind: %#v", m.Kind)
	}
}

func (m Method) Docs() string {
	if m.Docs_ != "" {
		return m.Docs_
	}

	switch m.Kind {
	case MethodGoString:
		return "GoString implements [fmt.GoStringer]."
	case MethodString:
		return "String implements [fmt.Stringer]."
	default:
		return ""
	}
}

type MethodKind string

const (
	MethodString     MethodKind = "string"
	MethodGoString   MethodKind = "go-string"
	MethodFromString MethodKind = "from-string"
)

//go:embed generated.go.tmpl
var tmplText string

// makeDocs converts a data into doc comments.
func makeDocs(data, indent string) string {
	if data == "" {
		return ""
	}

	var out strings.Builder
	for _, line := range strings.Split(strings.TrimSpace(data), "\n") {
		out.WriteString(indent)
		if line == "" {
			out.WriteString("//\n")
			continue
		}
		out.WriteString("// ")
		out.WriteString(line)
		out.WriteString("\n")
	}
	return out.String()
}

func Main() error {
	var input struct {
		Binary, Package, Path string
		YAML                  []Enum
	}
	input.Package = os.Getenv("GOPACKAGE")
	input.Path = os.Getenv("GOFILE")

	buildinfo, err := buildinfo.ReadFile(os.Args[0])
	if err != nil {
		return err
	}
	input.Binary = buildinfo.Path

	text, err := os.ReadFile(input.Path + ".yaml")
	if err != nil {
		return err
	}
	if err := yaml.Unmarshal(text, &input.YAML); err != nil {
		return err
	}

	tmpl, err := template.New("generated.go.tmpl").Funcs(template.FuncMap{
		"makeDocs": makeDocs,
		"contains": slices.Contains[[]string],
	}).Parse(tmplText)
	if err != nil {
		return err
	}

	out, err := os.Create(input.Path)
	if err != nil {
		return err
	}
	defer out.Close()
	return tmpl.ExecuteTemplate(out, "generated.go.tmpl", input)
}

func main() {
	if err := Main(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
